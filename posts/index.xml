<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on fragrant Blog</title>
        <link>blog.251.wiki/posts/</link>
        <description>Recent content in Posts on fragrant Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 08 Mar 2019 14:11:19 +0000</lastBuildDate>
        <atom:link href="blog.251.wiki/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>php反序列化</title>
            <link>blog.251.wiki/posts/php-unserialize/</link>
            <pubDate>Fri, 08 Mar 2019 14:11:19 +0000</pubDate>
            
            <guid>blog.251.wiki/posts/php-unserialize/</guid>
            <description>序列化 想要理解反序列化，那么必须先了解下序列化。序列化简单来说就是将对象数据转换成一种可逆的数据结构来持久化存放或传输的形式。简单的一个例子就是将一个类中的成员变量值转换为字符串形式来持久化的保存变量的值。
注：序列化只保存类名和类中的变量以及变量对应的值，而不会保存类中的方法。
在php中使用serialize()函数来实现序列化。
序列化的常见格式：对象，JSON，字符串，数组，XML等形式。
一个简单的例子，定义一个test的类，然后添加一个成员变量t1，实例化对象然后将其序列化之后输出到页面上。
class test{ public $t1 = &amp;#34;12345&amp;#34;; } $a = new test(); $b = serialize($a); echo $b; 输出的结果为：
分别对应了：类型,类名长度，类名，变量个数，变量类型，变量长度，变量内容
O:4:&amp;#34;test&amp;#34;:1:{s:2:&amp;#34;t1&amp;#34;;s:5:&amp;#34;12345&amp;#34;;} 我们可以字符串拆成两部分，O:4:&amp;ldquo;test&amp;rdquo;:1: 其中O代表类型，4代表类名的长度，test为类名，1代表这个类只有一个成员变量。
{s:2:&amp;ldquo;t1&amp;rdquo;;s:5:&amp;ldquo;12345&amp;rdquo;;} s为变量名和内容，s为类型，2是长度，变量名是t1，s为变量值的类型，5是长度，12345是内容。
以上是成员变量为public的情况下，在php中除了public公开类型，还有protected和private，受保护的和私有类型。
class test{ public $t1 = &amp;#34;12345&amp;#34;; private $t2 = &amp;#34;1234&amp;#34;; protected $t3 = &amp;#34;123&amp;#34;; } $a = new test(); $b = serialize($a); echo $b; 通过对比可以发现，当变量为private的时候，t2前面会加上类名字，而protected类型则会在变量前面加上星号。
这里有个问题就是变量名的长度，这两种类型会分别加上两个%00,每个%00占一个字节的长度。
private：%00类%00成员变量
protected %00*%00
所以t2为：%00test%00t2，而t3的则是%00*%00t3。
O:4:&amp;#34;test&amp;#34;:3:{s:2:&amp;#34;t1&amp;#34;;s:5:&amp;#34;12345&amp;#34;;s:8:&amp;#34;testt2&amp;#34;;s:4:&amp;#34;1234&amp;#34;;s:5:&amp;#34;*t3&amp;#34;;s:3:&amp;#34;123&amp;#34;;} 反序列化 既然序列化是将对象数据转换字节流，那么反序列化那肯定就是将字符串还原成php代码。
php中反序列化的函数是unserialize()。
这段代码先将test1类实例化之后进行序列化输出内容，然后执行反序列化再输出反序列化后的内容。
class test1{ public $t1 = &amp;#34;123456&amp;#34;; } $a1 = new test1(); $a2 = serialize($a1); echo $a2; $a3 = unserialize($a2); var_dump($a3); 那么问题来了，反序列化漏洞到底是什么情况？当一个对象被序列化或者是反序列化时，在php序列化的不同步骤下，php会自动去检测对应的魔术方法，如果存在对应的魔术方法，那么就会执行该方法内对应的代码。</description>
            <content type="html"><![CDATA[<h3 id="序列化">序列化</h3>
<p>想要理解反序列化，那么必须先了解下序列化。序列化简单来说就是将对象数据转换成一种可逆的数据结构来持久化存放或传输的形式。简单的一个例子就是将一个类中的成员变量值转换为字符串形式来持久化的保存变量的值。</p>
<p>注：序列化只保存类名和类中的变量以及变量对应的值，而不会保存类中的方法。</p>
<p>在php中使用serialize()函数来实现序列化。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/920312/1594262159072-660b719f-ef67-4a7a-9e5f-5fabaa7a2084.png" alt="img"></p>
<p>序列化的常见格式：对象，JSON，字符串，数组，XML等形式。</p>
<p>一个简单的例子，定义一个test的类，然后添加一个成员变量t1，实例化对象然后将其序列化之后输出到页面上。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">class test{
    public $t1 = &#34;12345&#34;;

}

$a = new test();
$b = serialize($a);
echo $b;
</code></pre></div><p>输出的结果为：</p>
<p>分别对应了：类型,类名长度，类名，变量个数，变量类型，变量长度，变量内容</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">O:</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">:</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#960050;background-color:#1e0010">:</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">:</span>{<span style="color:#960050;background-color:#1e0010">s:2:</span><span style="color:#f92672">&#34;t1&#34;</span><span style="color:#960050;background-color:#1e0010">;s</span>:<span style="color:#ae81ff">5</span>:<span style="color:#e6db74">&#34;12345&#34;</span><span style="color:#960050;background-color:#1e0010">;</span>} 
</code></pre></div><p>我们可以字符串拆成两部分，O:4:&ldquo;test&rdquo;:1: 其中O代表类型，4代表类名的长度，test为类名，1代表这个类只有一个成员变量。</p>
<p>{s:2:&ldquo;t1&rdquo;;s:5:&ldquo;12345&rdquo;;} s为变量名和内容，s为类型，2是长度，变量名是t1，s为变量值的类型，5是长度，12345是内容。</p>
<p>以上是成员变量为public的情况下，在php中除了public公开类型，还有protected和private，受保护的和私有类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">class test{
    public $t1 = &#34;12345&#34;;
    private $t2 = &#34;1234&#34;;
    protected  $t3 = &#34;123&#34;;
}

$a = new test();
$b = serialize($a);
echo $b;
</code></pre></div><p>通过对比可以发现，当变量为private的时候，t2前面会加上类名字，而protected类型则会在变量前面加上星号。</p>
<p>这里有个问题就是变量名的长度，这两种类型会分别加上两个%00,每个%00占一个字节的长度。</p>
<p>private：%00类%00成员变量</p>
<p>protected %00*%00</p>
<p>所以t2为：%00test%00t2，而t3的则是%00*%00t3。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">O:</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">:</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#960050;background-color:#1e0010">:</span><span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">:</span>{<span style="color:#960050;background-color:#1e0010">s:2:</span><span style="color:#f92672">&#34;t1&#34;</span><span style="color:#960050;background-color:#1e0010">;s</span>:<span style="color:#ae81ff">5</span>:<span style="color:#e6db74">&#34;12345&#34;</span><span style="color:#960050;background-color:#1e0010">;s</span>:<span style="color:#ae81ff">8</span>:<span style="color:#e6db74">&#34;testt2&#34;</span><span style="color:#960050;background-color:#1e0010">;s</span>:<span style="color:#ae81ff">4</span>:<span style="color:#e6db74">&#34;1234&#34;</span><span style="color:#960050;background-color:#1e0010">;s</span>:<span style="color:#ae81ff">5</span>:<span style="color:#e6db74">&#34;*t3&#34;</span><span style="color:#960050;background-color:#1e0010">;s</span>:<span style="color:#ae81ff">3</span>:<span style="color:#e6db74">&#34;123&#34;</span><span style="color:#960050;background-color:#1e0010">;</span>}
</code></pre></div><h3 id="反序列化">反序列化</h3>
<p>既然序列化是将对象数据转换字节流，那么反序列化那肯定就是将字符串还原成php代码。</p>
<p>php中反序列化的函数是unserialize()。</p>
<p>这段代码先将test1类实例化之后进行序列化输出内容，然后执行反序列化再输出反序列化后的内容。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">class test1{

    public $t1 = &#34;123456&#34;;

}


$a1 = new test1();
$a2 = serialize($a1);
echo $a2;
$a3 = unserialize($a2);
var_dump($a3);
</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2020/png/920312/1594106228409-58ec076b-c027-4188-8aa4-4a96be4092dd.png" alt="img"></p>
<p>那么问题来了，反序列化漏洞到底是什么情况？当一个对象被序列化或者是反序列化时，在php序列化的不同步骤下，php会自动去检测对应的魔术方法，如果存在对应的魔术方法，那么就会执行该方法内对应的代码。</p>
<p>来看一个反序列化中常见的魔术方法 __wakeup()，这个方法会在反序列化时自动去调用。</p>
<p>基于上面的代码增加一个wakeup方法，先实例化test类然后将其反序列化。当变量A的内容被反序列之后会自动触发__wakeup，输出t1变量的值和wakeup。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">class test{
    public $t1 = &#34;12345&#34;;

    function __wakeup()
    {
        echo $this-&gt;t1.&#34;&lt;/<span style="color:#f92672">br</span>&gt;&#34;;
                echo &#34;wakeup&#34;;
    }
}

$a = new test();
$b = serialize($a);
$c = unserialize($b);
</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2020/png/920312/1594105294246-80f8f048-a34a-4f1a-88fc-c3e54e83849d.png" alt="img"></p>
<p>那么如果反序列化的内容是可控的，同时存在魔术方法并会进入到一些危险的函数执行操作的话，那么就可以通过构造反序列化的内容覆盖掉原变量的内容，形成反序列漏洞。</p>
<p>一个简单的例子，基于上面的代码稍微改动下，通过GET方式获取传进来的内容然后直接反序列化。__destruct方法会在反序列化完毕之后被自动调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">error_reporting(0);
class test1{

    public $t1 = &#34;123456&#34;;

    function __destruct()
    {
        eval($this-&gt;t1);
    }

}

$a = $_GET[&#39;str&#39;];
$b = unserialize($a);
</code></pre></div><p>这里在__destruct方法内使用了eval函数来执行t1变量的值，t1变量的值是写死的，但是我们可以通过构造反序列化的内容来覆盖掉t1的默认值来实现命令执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">class test1{
    public $t1 = &#34;phpinfo();&#34;;

}

$a = new test1();
$b = serialize($a);
echo $b;

O:5:&#34;test1&#34;:1:{s:2:&#34;t1&#34;;s:10:&#34;phpinfo();&#34;;}
</code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2020/png/920312/1594106856009-84a124a8-a363-43ac-bb37-1b75d0b15a92.png" alt="img"></p>
<p>简单总结下反序列化漏洞，反序列化的内容可控，结合魔术方法中存在的危险代码通过构造反序列化的内容覆盖掉原本的内容，进入到危险代码中执行。反序列化漏洞的危害取决于相关魔术方法内的代码。</p>
<h3 id="php中常见的魔术方法">php中常见的魔术方法</h3>
<p>更多方法参考php官方手册，以下方法可自行尝试。</p>
<pre><code>__construct //对象被创建时调用
__destruct //对象销毁时被调用，php默认会自动销毁对象
__wakeup //反序列化时自动调用
__sleep //序列化时自动调用
__tostring //当一个类被当成字符串时，必须返回一个字符串，否则抛出错误
</code></pre>]]></content>
        </item>
        
    </channel>
</rss>
