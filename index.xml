<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fragrant Blog</title>
    <link>blog.251.wiki/</link>
    <description>Recent content on fragrant Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 20 Jan 2015 14:11:45 +0000</lastBuildDate>
    
	<atom:link href="blog.251.wiki/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>php反序列化</title>
      <link>blog.251.wiki/posts/php-unserialize/</link>
      <pubDate>Fri, 08 Mar 2019 14:11:19 +0000</pubDate>
      
      <guid>blog.251.wiki/posts/php-unserialize/</guid>
      <description>序列化 想要理解反序列化，那么必须先了解下序列化。序列化简单来说就是将对象数据转换成一种可逆的数据结构来持久化存放或传输的形式。简单的一个例子就是将一个类中的成员变量值转换为字符串形式来持久化的保存变量的值。
注：序列化只保存类名和类中的变量以及变量对应的值，而不会保存类中的方法。
在php中使用serialize()函数来实现序列化。
序列化的常见格式：对象，JSON，字符串，数组，XML等形式。
一个简单的例子，定义一个test的类，然后添加一个成员变量t1，实例化对象然后将其序列化之后输出到页面上。
class test{ public $t1 = &amp;#34;12345&amp;#34;; } $a = new test(); $b = serialize($a); echo $b; 输出的结果为：
分别对应了：类型,类名长度，类名，变量个数，变量类型，变量长度，变量内容
O:4:&amp;#34;test&amp;#34;:1:{s:2:&amp;#34;t1&amp;#34;;s:5:&amp;#34;12345&amp;#34;;} 我们可以字符串拆成两部分，O:4:&amp;ldquo;test&amp;rdquo;:1: 其中O代表类型，4代表类名的长度，test为类名，1代表这个类只有一个成员变量。
{s:2:&amp;ldquo;t1&amp;rdquo;;s:5:&amp;ldquo;12345&amp;rdquo;;} s为变量名和内容，s为类型，2是长度，变量名是t1，s为变量值的类型，5是长度，12345是内容。
以上是成员变量为public的情况下，在php中除了public公开类型，还有protected和private，受保护的和私有类型。
class test{ public $t1 = &amp;#34;12345&amp;#34;; private $t2 = &amp;#34;1234&amp;#34;; protected $t3 = &amp;#34;123&amp;#34;; } $a = new test(); $b = serialize($a); echo $b; 通过对比可以发现，当变量为private的时候，t2前面会加上类名字，而protected类型则会在变量前面加上星号。
这里有个问题就是变量名的长度，这两种类型会分别加上两个%00,每个%00占一个字节的长度。
private：%00类%00成员变量
protected %00*%00
所以t2为：%00test%00t2，而t3的则是%00*%00t3。
O:4:&amp;#34;test&amp;#34;:3:{s:2:&amp;#34;t1&amp;#34;;s:5:&amp;#34;12345&amp;#34;;s:8:&amp;#34;testt2&amp;#34;;s:4:&amp;#34;1234&amp;#34;;s:5:&amp;#34;*t3&amp;#34;;s:3:&amp;#34;123&amp;#34;;} 反序列化 既然序列化是将对象数据转换字节流，那么反序列化那肯定就是将字符串还原成php代码。
php中反序列化的函数是unserialize()。
这段代码先将test1类实例化之后进行序列化输出内容，然后执行反序列化再输出反序列化后的内容。
class test1{ public $t1 = &amp;#34;123456&amp;#34;; } $a1 = new test1(); $a2 = serialize($a1); echo $a2; $a3 = unserialize($a2); var_dump($a3); 那么问题来了，反序列化漏洞到底是什么情况？当一个对象被序列化或者是反序列化时，在php序列化的不同步骤下，php会自动去检测对应的魔术方法，如果存在对应的魔术方法，那么就会执行该方法内对应的代码。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>blog.251.wiki/about/</link>
      <pubDate>Tue, 20 Jan 2015 14:11:45 +0000</pubDate>
      
      <guid>blog.251.wiki/about/</guid>
      <description>Email：ZnJhZ3JhbnQuZkBwcm90b25tYWlsLmNvbQ==</description>
    </item>
    
  </channel>
</rss>